{
  "1. Half Adder": "// 1. Half Adder\nmodule half_adder(\n    input a,\n    input b,\n    output sum,\n    output carry\n);\n    assign sum = a ^ b;\n    assign carry = a & b;\nendmodule",
  
  "2. Full Adder": "// 2. Full Adder\nmodule full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule",
  
  "3. Parameterized Adder": "// 3. Parameterized Adder\nmodule param_adder #(parameter WIDTH = 8)(\n    input [WIDTH-1:0] a,\n    input [WIDTH-1:0] b,\n    output [WIDTH-1:0] sum,\n    output carry\n);\n    assign {carry, sum} = a + b;\nendmodule",
  
  "4. Parameterized Subtractor": "// 4. Parameterized Subtractor\nmodule param_subtractor #(parameter WIDTH = 8)(\n    input [WIDTH-1:0] a,\n    input [WIDTH-1:0] b,\n    output [WIDTH-1:0] diff,\n    output borrow\n);\n    assign {borrow, diff} = {1'b0, a} - b;\nendmodule",
  
  "5. Parameterized Multiplier": "// 5. Parameterized Multiplier\nmodule param_multiplier #(parameter WIDTH = 8)(\n    input [WIDTH-1:0] a,\n    input [WIDTH-1:0] b,\n    output [2*WIDTH-1:0] product\n);\n    assign product = a * b;\nendmodule",
  
  "6. Parameterized Divider": "// 6. Parameterized Divider\nmodule param_divider #(parameter WIDTH = 8)(\n    input [WIDTH-1:0] dividend,\n    input [WIDTH-1:0] divisor,\n    output [WIDTH-1:0] quotient,\n    output [WIDTH-1:0] remainder\n);\n    assign quotient = dividend / divisor;\n    assign remainder = dividend % divisor;\nendmodule",
  
  "7. 32-bit Register File": "// 7. 32-bit Register File\nmodule reg_file_32bit(\n    input clk,\n    input rst,\n    input we,\n    input [4:0] read_addr1,\n    input [4:0] read_addr2,\n    input [4:0] write_addr,\n    input [31:0] write_data,\n    output [31:0] read_data1,\n    output [31:0] read_data2\n);\n    reg [31:0] regs [31:0];\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            integer i;\n            for (i = 0; i < 32; i = i + 1) regs[i] <= 32'b0;\n        end else if (we) begin\n            regs[write_addr] <= write_data;\n        end\n    end\n\n    assign read_data1 = regs[read_addr1];\n    assign read_data2 = regs[read_addr2];\nendmodule",
  
  "8. Parameterized Shift Register": "// 8. Parameterized Shift Register\nmodule param_shift_reg #(parameter WIDTH = 8)(\n    input clk,\n    input rst,\n    input load,\n    input [WIDTH-1:0] data_in,\n    output reg [WIDTH-1:0] data_out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            data_out <= 0;\n        else if (load)\n            data_out <= data_in;\n    end\nendmodule",
  
  "9. 4-bit ALU": "// 9. 4-bit ALU\nmodule alu_4bit(\n    input [3:0] a,\n    input [3:0] b,\n    input [2:0] ALU_Sel,\n    output reg [3:0] ALU_Result,\n    output Zero,\n    output reg Carry,\n    output reg Overflow\n);\n    always @(*) begin\n        case (ALU_Sel)\n            3'b000: {Carry, ALU_Result} = a + b;           // ADD\n            3'b001: {Carry, ALU_Result} = a - b;           // SUB\n            3'b010: ALU_Result = a & b;                    // AND\n            3'b011: ALU_Result = a | b;                    // OR\n            3'b100: ALU_Result = a ^ b;                    // XOR\n            3'b101: ALU_Result = ~a;                       // NOT\n            3'b110: ALU_Result = a << 1;                   // SHL\n            3'b111: ALU_Result = a >> 1;                   // SHR\n        endcase\n        Overflow = (ALU_Sel == 3'b000) && ((a[3] == b[3]) && (ALU_Result[3] != a[3]));\n    end\n    assign Zero = (ALU_Result == 4'b0000);\nendmodule",
  
  "10. RAM": "// 10. RAM\nmodule ram_simple #(parameter DATA_WIDTH = 8, ADDR_WIDTH = 8)(\n    input clk,\n    input we,\n    input [ADDR_WIDTH-1:0] addr,\n    input [DATA_WIDTH-1:0] data_in,\n    output reg [DATA_WIDTH-1:0] data_out\n);\n    reg [DATA_WIDTH-1:0] mem [(1<<ADDR_WIDTH)-1:0];\n\n    always @(posedge clk) begin\n        if (we)\n            mem[addr] <= data_in;\n        data_out <= mem[addr];\n    end\nendmodule",
  
  "11. ROM": "// 11. ROM\nmodule rom_simple #(parameter DATA_WIDTH = 8, ADDR_WIDTH = 8)(\n    input [ADDR_WIDTH-1:0] addr,\n    output [DATA_WIDTH-1:0] data_out\n);\n    reg [DATA_WIDTH-1:0] mem [(1<<ADDR_WIDTH)-1:0];\n    initial $readmemh(\"rom_data.mem\", mem);\n    assign data_out = mem[addr];\nendmodule",

  "12. FSM (1100 pattern)": "// 12. FSM (1100 pattern)\nmodule fsm_1100(\n    input clk,\n    input rst,\n    input bit_in,\n    output reg pattern_detected\n);\n    typedef enum reg [1:0] {S0, S1, S2, S3} state_t;\n    state_t state, next_state;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            S0: next_state = bit_in ? S1 : S0;\n            S1: next_state = bit_in ? S2 : S0;\n            S2: next_state = bit_in ? S2 : S3;\n            S3: next_state = bit_in ? S1 : S0;\n        endcase\n    end\n\n    always @(*)\n        pattern_detected = (state == S3 && bit_in == 0);\nendmodule",

  "13. Fibonacci Number Generator": "// 13. Fibonacci Number Generator\nmodule fibonacci_gen #(parameter WIDTH = 8) (\n    input clk,\n    input rst,\n    input start,\n    input [WIDTH-1:0] n,\n    output reg [WIDTH-1:0] fib\n);\n    reg [WIDTH-1:0] a, b;\n    reg [WIDTH-1:0] count;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            a <= 0;\n            b <= 1;\n            fib <= 0;\n            count <= 0;\n        end else if (start) begin\n            if (count < n) begin\n                fib <= a + b;\n                a <= b;\n                b <= a + b;\n                count <= count + 1;\n            end\n        end\n    end\nendmodule",

  "14. Binary Adder Tree": "// 14. Binary Adder Tree\nmodule binary_adder_tree(A, B, C, D, E, clk, out);\n\n\tinput\t[15:0] A, B, C, D, E;\n\tinput\tclk;\n\toutput\t[15:0] out;\n\n\twire\t[15:0]    sum1, sum2, sum3, sum4;\n\treg\t\t[15:0]   sumreg1, sumreg2, sumreg3, sumreg4;\n\n\talways @ (posedge clk)\n\t\tbegin\n\t\t\tsumreg1 <= sum1;\n\t\t\tsumreg2 <= sum2;\n\t\t\tsumreg3 <= sum3;\n\t\t\tsumreg4 <= sum4;\n\t\tend\n\n\tassign sum1 = A + B;\n\tassign sum2 = C + D;\n\tassign sum3 = sumreg1 + sumreg2;\n\tassign sum4 = sumreg3 + E;\n\tassign out = sumreg4;\n\nendmodule",

  "15. Ternary Adder Tree": "// 15. Ternary Adder Tree\nmodule ternary_adder_tree(A, B, C, D, E, CLK, OUT);\n\tparameter WIDTH = 16;\n\n\tinput [WIDTH-1:0] A, B, C, D, E;\n\tinput CLK;\n\toutput [WIDTH-1:0] OUT;\n\n\twire [WIDTH-1:0] sum1, sum2;\n\treg [WIDTH-1:0] sumreg1, sumreg2;\n\n\talways @ (posedge CLK)\n\t\tbegin\n\t\t\tsumreg1 <= sum1;\n\t\t\tsumreg2 <= sum2;\n\t\tend\n\n\tassign sum1 = A + B + C;\n\tassign sum2 = sumreg1 + D + E;\n\tassign OUT = sumreg2;\n\nendmodule",

  "16. Dual Clock Synchronous RAM": "// 16. Dual Clock Synchronous RAM\nmodule ram_dual\n(\n\tinput [7:0] data,\n\tinput [5:0] read_addr, write_addr,\n\tinput we, read_clock, write_clock,\n\toutput reg [7:0] q\n);\n\n\treg [7:0] ram[63:0];\n\n\talways @ (posedge write_clock)\n\tbegin\n\t\tif (we)\n\t\t\tram[write_addr] <= data;\n\tend\n\n\talways @ (posedge read_clock)\n\tbegin\n\t\tq <= ram[read_addr];\n\tend\nendmodule",

  "17. Single Clock Synchronous RAM": "// 17. Single Clock Synchronous RAM\nmodule ram_infer\n(\n\tinput [7:0] data,\n\tinput [5:0] read_addr, write_addr,\n\tinput we, clk,\n\toutput reg [7:0] q\n);\n\n\treg [7:0] ram[63:0];\n\n\talways @ (posedge clk)\n\tbegin\n\t\tif (we)\n\t\t\tram[write_addr] <= data;\n\t\tq <= ram[read_addr];\n\tend\n\nendmodule",

  "18. RAM with Separate I/O Ports": "// 18. RAM with Separate I/O Ports\nmodule ram_separate_io #(\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 8\n) (\n    input clk,\n    input we,\n    input [ADDR_WIDTH-1:0] addr,\n    input [DATA_WIDTH-1:0] data_in,\n    output reg [DATA_WIDTH-1:0] data_out\n);\n    reg [DATA_WIDTH-1:0] ram[2**ADDR_WIDTH-1:0];\n\n    always @(posedge clk) begin\n        if (we)\n            ram[addr] <= data_in;\n        data_out <= ram[addr];\n    end\nendmodule",

  "19. Single-Port RAM": "// 19. Single-Port RAM\nmodule single_port_ram\n(\n\tinput [7:0] data,\n\tinput [5:0] addr,\n\tinput we, clk,\n\toutput [7:0] q\n);\n\n\treg [7:0] ram[63:0];\n\treg [5:0] addr_reg;\n\n\talways @ (posedge clk)\n\tbegin\n\t\tif (we)\n\t\t\tram[addr] <= data;\n\t\taddr_reg <= addr;\n\tend\n\n\tassign q = ram[addr_reg];\n\nendmodule",

  "20. Counter with Asynchronous Reset": "// 20. Counter with Asynchronous Reset\nmodule counter\n(\n\tclk,\n\treset,\n\tresult,\n\tena\n);\n\n\tinput clk;\n\tinput reset;\n\tinput ena;\n\toutput [7:0] result;\n\n\treg [7:0] result;\n\n\talways @(posedge clk or posedge reset)\n\tbegin\n\t\tif (reset)\n\t\t\tresult = 0;\n\t\telse if (ena)\n\t\t\tresult = result + 1;\n\tend\nendmodule",

  "21. Bidirectional Pin": "// 21. Bidirectional Pin\nmodule bidir_pin #(\n    parameter WIDTH = 1\n)(\n    inout [WIDTH-1:0] pin,\n    input dir,\n    input [WIDTH-1:0] data_out,\n    output [WIDTH-1:0] data_in\n);\n\n    assign pin = dir ? data_out : {WIDTH{1'bz}};\n    assign data_in = pin;\n\nendmodule",

  "22. UART (Universal Asynchronous Receiver-Transmitter)": "// 22. UART (Universal Asynchronous Receiver-Transmitter)\nmodule uart_module #(\n    parameter BAUD_RATE = 9600\n)(\n    input clk,\n    input rst,\n    input rx,\n    output tx,\n    input [7:0] data_in,\n    output [7:0] data_out\n);\n    // Stub for UART logic\n    // Add UART TX/RX logic here\nendmodule",

  "23. FFT Module": "// 23. FFT Module\nmodule fft_module #(\n    parameter DATA_WIDTH = 16,\n    parameter FFT_POINTS = 1024\n)(\n    input clk,\n    input rst,\n    input start,\n    input [DATA_WIDTH-1:0] data_in,\n    output [DATA_WIDTH-1:0] data_out,\n    output done\n);\n    // Stub for FFT logic\nendmodule",

  "24. Digital Filter": "// 24. Digital Filter\nmodule digital_filter #(\n    parameter DATA_WIDTH = 16,\n    parameter COEFF_WIDTH = 16,\n    parameter NUM_TAPS = 32\n)(\n    input clk,\n    input rst,\n    input [DATA_WIDTH-1:0] data_in,\n    output [DATA_WIDTH-1:0] data_out,\n    input [COEFF_WIDTH-1:0] coeff [NUM_TAPS-1:0]\n);\n    // Stub for filter logic\nendmodule",

  "25. BCD to Gray Converter": "// Module 25: BCD to Gray Converter\n`timescale 1ns / 1ps\nmodule bcd_to_gray #(\n    parameter BCD_WIDTH = 4,\n    parameter GRAY_WIDTH = 4\n)(\n    input [BCD_WIDTH-1:0] bcd,\n    output [GRAY_WIDTH-1:0] gray\n);\n    assign gray = bcd ^ (bcd >> 1);\nendmodule",

  "26. 7 Segment LCD": "// Module 26: 7 Segment LCD\n`timescale 1ns / 1ps\nmodule seven_seg_display #(\n    parameter DATA_WIDTH = 4\n)(\n    input [DATA_WIDTH-1:0] data,\n    output reg [6:0] seg\n);\n    always @(*) begin\n        case (data)\n            4'h0: seg = 7'b1000000;\n            4'h1: seg = 7'b1111001;\n            4'h2: seg = 7'b0100100;\n            4'h3: seg = 7'b0110000;\n            4'h4: seg = 7'b0011001;\n            4'h5: seg = 7'b0010010;\n            4'h6: seg = 7'b0000010;\n            4'h7: seg = 7'b1111000;\n            4'h8: seg = 7'b0000000;\n            4'h9: seg = 7'b0011000;\n            4'hA: seg = 7'b0001000;\n            4'hB: seg = 7'b0000011;\n            4'hC: seg = 7'b1000110;\n            4'hD: seg = 7'b0100001;\n            4'hE: seg = 7'b0000110;\n            4'hF: seg = 7'b0001110;\n            default: seg = 7'b1111111;\n        endcase\n    end\nendmodule",

  "27. Gray Counter (Design 1)": "// Module 27: Gray Counter (Design 1)\nmodule gray_count\n(\n\tinput clk, enable, reset,\n\toutput reg [7:0] gray_count\n);\n\n\treg q [7:-1];\n\treg no_ones_below [7:-1];\n\treg q_msb;\n\n\tinteger i, j, k;\n\n\talways @ (posedge reset or posedge clk)\n\tbegin\n\t\tif (reset)\n\t\tbegin\n\t\t\tq[-1] <= 1;\n\t\t\tfor (i = 0; i <= 7; i = i + 1)\n\t\t\t\tq[i] <= 0;\n\t\tend\n\t\telse if (enable)\n\t\tbegin\n\t\t\tq[-1] <= ~q[-1];\n\t\t\tfor (i = 0; i < 7; i = i + 1)\n\t\t\t\tq[i] <= q[i] ^ (q[i-1] & no_ones_below[i-1]);\n\t\t\tq[7] <= q[7] ^ (q_msb & no_ones_below[6]);\n\t\tend\n\tend\n\n\talways @(*)\n\tbegin\n\t\tno_ones_below[-1] <= 1;\n\t\tfor (j = 0; j < 7; j = j + 1)\n\t\t\tno_ones_below[j] <= no_ones_below[j-1] & ~q[j-1];\n\t\tq_msb <= q[7] | q[6];\n\t\tfor (k = 0; k < 8; k = k + 1)\n\t\t\tgray_count[k] <= q[k];\n\tend\t\nendmodule",

  "28. Behavioral Counter (Design 2)": "// Module 28: Behavioral Counter (Design 2)\nmodule behav_counter( d, clk, clear, load, up_down, qd);\n\ninput [7:0] d;\ninput clk;\ninput clear;\ninput load;\ninput up_down;\noutput reg [7:0] cnt;\n\nalways @ (posedge clk)\nbegin\n    if (!clear)\n        cnt <= 8'h00;\n    else if (load)\n        cnt <= d;\n    else if (up_down)\n        cnt <= cnt + 1;\n    else\n        cnt <= cnt - 1;\nend \n\nendmodule",

  "29. Parameterized Comparator (Design 3)": "// Module 29: Parameterized Comparator (Design 3)\n`timescale 1ns / 1ps\nmodule param_comparator #(\n    parameter WIDTH = 8\n)(\n    input [WIDTH-1:0] A,\n    input [WIDTH-1:0] B,\n    output Equal,\n    output Greater,\n    output Less\n);\n    assign Equal = (A == B);\n    assign Greater = (A > B);\n    assign Less = (A < B);\nendmodule",

  "30. Modulation and Demodulation (Design 4)": "// Module 30: Modulation and Demodulation (Design 4)\n`timescale 1ns / 1ps\nmodule mod_demod #(\n    parameter DATA_WIDTH = 16\n)(\n    input clk,\n    input rst,\n    input [DATA_WIDTH-1:0] data_in,\n    output [DATA_WIDTH-1:0] modulated_signal,\n    output [DATA_WIDTH-1:0] demodulated_data\n);\n    assign modulated_signal = data_in ^ {DATA_WIDTH{1'b1}};\n    assign demodulated_data = modulated_signal ^ {DATA_WIDTH{1'b1}};\nendmodule",

  "31. Parameterized Counter (Design 5)": "// Module 31: Parameterized Counter (Design 5)\n`timescale 1ns / 1ps\nmodule param_counter #(\n    parameter MAX_COUNT = 255\n)(\n    input clk,\n    input rst,\n    output reg [$clog2(MAX_COUNT+1)-1:0] count\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            count <= 0;\n        else if (count < MAX_COUNT)\n            count <= count + 1;\n        else\n            count <= 0;\n    end\nendmodule",

  "32. True Dual-Port RAM with a Single Clock (Design 6)": "// Module 32: True Dual-Port RAM with a Single Clock (Design 6)\nmodule true_dpram_sclk\n(\n\tinput [7:0] data_a, data_b,\n\tinput [5:0] addr_a, addr_b,\n\tinput we_a, we_b, clk,\n\toutput reg [7:0] q_a, q_b\n);\n\treg [7:0] ram[63:0];\n\n\t// Port A\n\talways @ (posedge clk)\n\tbegin\n\t\tif (we_a) \n\t\tbegin\n\t\t\tram[addr_a] <= data_a;\n\t\t\tq_a <= data_a;\n\t\tend\n\t\telse \n\t\tbegin\n\t\t\tq_a <= ram[addr_a];\n\t\tend\n\tend\n\n\t// Port B\n\talways @ (posedge clk)\n\tbegin\n\t\tif (we_b)\n\t\tbegin\n\t\t\tram[addr_b] <= data_b;\n\t\t\tq_b <= data_b;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tq_b <= ram[addr_b];\n\t\tend\n\tend\nendmodule",

  "33. 8x64 Shift Register with Taps": "// Module 33: 8x64 Shift Register with Taps\nmodule shift_8x64_taps \t\t\t\t(clk, \n\t\t\t\tshift,\n\t\t\t\tsr_in,\n\t\t\t\tsr_out,\n\t\t\t\tsr_tap_one,\n\t\t\t\tsr_tap_two,\n\t\t\t\tsr_tap_three,\n \t\t\t\t);\n  \n\tinput clk, shift;\n\n\tinput [7:0] sr_in;\n\toutput [7:0] sr_tap_one, sr_tap_two, sr_tap_three, sr_out;\n\n\treg [7:0] sr [63:0];\n\tinteger n;\n\n \talways@(posedge clk)\n\tbegin\n\t\tif (shift == 1'b1)\n\t\tbegin\n\t\t\tfor (n = 63; n>0; n = n-1)\n\t\t\tbegin\n\t\t\t\tsr[n] <= sr[n-1];\n\t\t\tend \n\n\t\t\tsr[0] <= sr_in;\n\t\tend \n\tend \n\t\n\tassign sr_tap_one = sr[15];\n\tassign sr_tap_two = sr[31];\n\tassign sr_tap_three = sr[47];\n\tassign sr_out = sr[63];\n\nendmodule"
}






